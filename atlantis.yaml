version: 3
automerge: false
parallel_plan: false
parallel_apply: false

projects:
  - name: apps-staging
    dir: .
    terraform_version: v1.6.6
    autoplan:
      enabled: true
      when_modified:
        - "application/**"
    workflow: staging-workflow
    apply_requirements: []

  - name: apps-production
    dir: .
    terraform_version: v1.6.6
    autoplan:
      enabled: true
      when_modified:
        - "application/**"
    workflow: production-workflow
    apply_requirements: [approved, mergeable]

  - name: apps-helia
    dir: .
    terraform_version: v1.6.6
    autoplan:
      enabled: true
      when_modified:
        - "application/**"
    workflow: helia-workflow
    apply_requirements: []

workflows:
  staging-workflow:
    plan:
      steps:
        - env:
            name: APP_FILTER
            command: echo "$COMMENT_ARGS" | tr -d '\\'
        - run:
            command: |
              set -euo pipefail
              ENV="staging"
              echo "ðŸ”µ Running Staging plan with APP_FILTER='$APP_FILTER'"
              # Use project-specific files
              PLANLIST="/tmp/atlantis_planfiles_staging.lst"
              rm -f "$PLANLIST"
              chmod +x ./scripts/process-application.sh
              ./scripts/process-application.sh "$ENV" "$APP_FILTER"
        - run:
            command: |
              ENV="staging"
              PLANLIST="/tmp/atlantis_planfiles_${ENV}.lst"
              if [[ -f "$PLANLIST" ]]; then
                echo ""
                echo "---"
                echo "## ðŸš€ Staging Apply Commands"
                echo ""
                # Read only well-formed plan lines and avoid calling external basename (BusyBox basename treats args starting with '-' as options).
                # Use shell parameter expansion to extract the final path component safely.
                while IFS='|' read -r d PLAN; do
                  # skip empty lines or lines that don't look like a path ("d" should be a path)
                  if [[ -z "$d" || "$d" != */* ]]; then
                    continue
                  fi
                  # extract last path element without using `basename` to avoid BusyBox option-parsing issues
                  APP_NAME="${d##*/}"
                  APP_NAME="$(printf '%s' "$APP_NAME" | tr -d '[:space:]')"
                  if [[ -n "$APP_NAME" ]]; then
                    echo "**Apply $APP_NAME:**"
                    echo '```shell'
                    echo "atlantis apply -p apps-staging -- $APP_NAME"
                    echo '```'
                    echo ""
                  fi
                done < "$PLANLIST"
                echo "**Apply all staging applications:**"
                echo '```shell'
                echo "atlantis apply -p apps-staging"
                echo '```'
              fi

    apply:
      steps:
        - env:
            name: APP_FILTER
            command: echo "$COMMENT_ARGS" | tr -d '\\'
        - run:
            command: |
              set -euo pipefail
              ENV="staging"
              echo "ðŸ”µ Applying Staging changes with APP_FILTER='$APP_FILTER'"
              chmod +x ./scripts/apply-plans.sh
              ./scripts/apply-plans.sh "$ENV" "$APP_FILTER"

  production-workflow:
    plan:
      steps:
        - env:
            name: APP_FILTER
            command: echo "$COMMENT_ARGS" | tr -d '\\'
        - run:
            command: |
              set -euo pipefail
              ENV="production"
              echo "ðŸ”´ Running Production plan with APP_FILTER='$APP_FILTER'"
              # Use project-specific files
              PLANLIST="/tmp/atlantis_planfiles_production.lst"
              rm -f "$PLANLIST"
              chmod +x ./scripts/process-application.sh
              ./scripts/process-application.sh "$ENV" "$APP_FILTER"
        - run:
            command: |
              ENV="production"
              PLANLIST="/tmp/atlantis_planfiles_${ENV}.lst"
              if [[ -f "$PLANLIST" ]]; then
                echo ""
                echo "---"
                echo "## ðŸš€ Production Apply Commands"
                echo ""
                while IFS='|' read -r d PLAN; do
                  if [[ -z "$d" || "$d" != */* ]]; then
                    continue
                  fi
                  APP_NAME="${d##*/}"
                  APP_NAME="$(printf '%s' "$APP_NAME" | tr -d '[:space:]')"
                  if [[ -n "$APP_NAME" ]]; then
                    echo "**Apply $APP_NAME:**"
                    echo '```shell'
                    echo "atlantis apply -p apps-production -- $APP_NAME"
                    echo '```'
                    echo ""
                  fi
                done < "$PLANLIST"
                echo "**Apply all production applications:**"
                echo '```shell'
                echo "atlantis apply -p apps-production"
                echo '```'
              fi

    apply:
      steps:
        - env:
            name: APP_FILTER
            command: echo "$COMMENT_ARGS" | tr -d '\\'
        - run:
            command: |
              set -euo pipefail
              ENV="production"
              echo "ðŸ”´ Applying Production changes with APP_FILTER='$APP_FILTER'"
              chmod +x ./scripts/apply-plans.sh
              ./scripts/apply-plans.sh "$ENV" "$APP_FILTER"

  helia-workflow:
    plan:
      steps:
        - env:
            name: APP_FILTER
            command: echo "$COMMENT_ARGS" | tr -d '\\'
        - run:
            command: |
              set -euo pipefail
              ENV="helia"
              echo "ðŸŸ£ Running Helia plan with APP_FILTER='$APP_FILTER'"
              # Use project-specific files
              PLANLIST="/tmp/atlantis_planfiles_helia.lst"
              rm -f "$PLANLIST"
              chmod +x ./scripts/process-application.sh
              ./scripts/process-application.sh "$ENV" "$APP_FILTER"
        - run:
            command: |
              ENV="helia"
              PLANLIST="/tmp/atlantis_planfiles_${ENV}.lst"
              if [[ -f "$PLANLIST" ]]; then
                echo ""
                echo "---"
                echo "## ðŸš€ Helia Apply Commands"
                echo ""
                while IFS='|' read -r d PLAN; do
                  if [[ -z "$d" || "$d" != */* ]]; then
                    continue
                  fi
                  APP_NAME="${d##*/}"
                  APP_NAME="$(printf '%s' "$APP_NAME" | tr -d '[:space:]')"
                  if [[ -n "$APP_NAME" ]]; then
                    echo "**Apply $APP_NAME:**"
                    echo '```shell'
                    echo "atlantis apply -p apps-helia -- $APP_NAME"
                    echo '```'
                    echo ""
                  fi
                done < "$PLANLIST"
                echo "**Apply all helia applications:**"
                echo '```shell'
                echo "atlantis apply -p apps-helia"
                echo '```'
              fi

    apply:
      steps:
        - env:
            name: APP_FILTER
            command: echo "$COMMENT_ARGS" | tr -d '\\'
        - run:
            command: |
              set -euo pipefail
              ENV="helia"
              echo "ðŸŸ£ Applying Helia changes with APP_FILTER='$APP_FILTER'"
              chmod +x ./scripts/apply-plans.sh
              ./scripts/apply-plans.sh "$ENV" "$APP_FILTER"